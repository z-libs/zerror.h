# zerror.h

`zerror.h` is a sophisticated, single-header error handling library for C and C++. It bridges the gap between low-level C programming and modern safety patterns found in languages like Rust or Swift by providing Result types, stack traces, and "Logical Stack Traces" through macro-driven decoration.

It is part of the [Zen Development Kit](https://github.com/z-libs/z-libs).

## Features

* **Type-Safe Results**: Generic `result<T>` patterns for both C (via macros) and C++.
* **Logical Stack Traces**: Capture file, line, and function names at the point of origin and throughout the propagation chain.
* **Zero-Allocation Printing**: Uses thread-local ring buffers for error message formatting to avoid heap fragmentation.
* **C++ Support**: Native C++11 wrapper with RAII `result<T>` and `std::ostream` integration.
* **Modern C Ergonomics**: Leverages `__attribute__((cleanup))` and statement expressions for `try`-like syntax on supported compilers.
* **Debug Integration**: Optional hardware breakpoints/traps (`ZERROR_TRAP`) when an error is created.

## Usage: C

Define result types and use the propagation macros to handle errors without boilerplate.

```c
#define ZERROR_IMPLEMENTATION
#include "zerror.h"

// Define a Result type that can return an int or a zerr.
DEFINE_RESULT(int, ResInt)

ResInt calculate(int val) 
{
    if (val < 0) 
    {
        // Creates error with file/line/func context.
        return ResInt_err(zerr_create(Z_EINVAL, "Value cannot be negative: %d", val));
    }
    return ResInt_ok(val * 2);
}

zres process() 
{
    // 'try' automatically unwraps value or returns error to caller.
    int x = try(calculate(-5)); 
    printf("Result: %d\n", x);
    return zres_ok();
}

int main() 
{
    // 'run' executes the logic and prints a formatted trace on failure.
    return run(process());
}
```

## Usage: C++

The C++ wrapper lives in the **`z_error`** namespace and provides a template-based `result<T>` that behaves similarly to `std::expected`.

```cpp
#include <iostream>
#define ZERROR_IMPLEMENTATION
#include "zerror.h"

z_error::result<int> compute(int n) 
{
    if (n == 0) 
    {
        return zerr_create(Z_ERR, "Division by zero");
    }
    return 100 / n;
}

int main()
{
    auto res = compute(0);
    if (!res) 
    {
        std::cerr << "Caught error: " << res.err << std::endl;
        return 1;
    }
    std::cout << "Value: " << res.unwrap_val() << std::endl;
    return 0;
}
```

[//]: # (ZDOC_START)
[//]: # (ZDOC_END)

## Configuration

Define these macros **before** including `zerror.h` to modify behavior:

| Macro | Description |
| :--- | :--- |
| `ZERROR_IMPLEMENTATION` | Define in **exactly one** `.c` or `.cpp` file to generate logic. |
| `ZERROR_SHORT_NAMES` | Enables shorter aliases (for example, `try`, `check`, `ensure`). |
| `ZERROR_DEBUG` | Enables hardware traps/breakpoints at the exact moment an error is created. |
| `ZERROR_ENABLE_TRACE` | Enables the collection of propagation traces. |
| `ZERROR_NO_COLOR` | Disables ANSI color codes in `zerr_print`. |
| `ZERROR_PANIC_ACTION` | Define to override the default `abort()` behavior. |

## Memory Management

`zerror.h` uses an internal thread-local ring buffer to handle error messages. This allows you to return formatted error messages from functions without worrying about `malloc` or `free`.

The common library (`zcommon.h` block) also allows you to override the standard allocators used by the system.
